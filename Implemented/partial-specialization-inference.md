---
description: Infer existing specializations based on a (partial) operation characteristics annotation stated upon declaration as well as other specializations.
author: Bettina Heim
date: 2019-04-03
---

# Partial Specialization Inference

## Proposal

Upon declaration each operation defines which functors can be applied to it, and how the resulting transformation is to be implemented. 
This proposal refers to the specification of the resulting transformation as "functor specialization" for the sake of a compact terminology, 
even though it is a specialization of the *operation* for a particular functor, or for a combination of functors, rather than the functor itself. 

The implementation for a particular functor specialization can either be specified explicitly as a code block or generated by the compiler based on a specified generation directive.
The generation directive `auto` instructs the compiler to determine a suitable directive based on which the implementation is generated.
Currently, the compiler generates a warning if a specialization declaration is missing that should exist based on other defined specializations. 
The proposal is to drop this warning and instead allow the compiler to infer the existence of specializations. 

Rather than a full inference across the entire compilation, the proposal is to do a partial inference limited to each individual callable.
Such a limited inference is facilitated by introducing the option to explicitly state (part of) the operation characteristics as part of the callable declaration. 
The existence of specializations can then be inferred based on explicitly defined specializations as well as the declared (possibly incomplete) characteristics. 
Conversely, the compiler should infer the correct (complete) characteristics based on the all existing specializations, user-defined or inferred and generated. 
The implementation for specializations inferred by the compiler then corresponds to the one for an explicit declaration specifying `auto` as generation directive. 

## Justification

Fully specifying the behavior of any supported combination of functor applications for an operation requires explicitly defining a number of functor specializations that grows exponentially with the number of supported functors. 
Furthermore, if type specializations for templates are allowed within Q# in the future, then each functor specialization needs to be specified for each type specialization as well. 
Especially in the common case where every implementation is specified by the auto directive, this generates a lot of unnecessary noise in Q# code.
Even though currently only two functors and no type specializations are supported, people therefore tend to omit declaring the specializations for all supported functors for brevity's sake unless there is an immediate need to do so. 
Given that the compiler already detects and generates a warning for missing specialization declarations in some cases, 
requiring to explicitly specify each existing specialization individually is largely unnecessary, 
especially considering that in the vast majority of cases using the generation directive `auto` results in the desired implementation. 

The proposal is to alleviate the burden on the developer in cases where functor specializations can be inferred and auto-generated by the compiler. 
Allowing to specify the operation characteristics or parts thereof as part of the callable declaration ensures that this inference can be limited to a particular operation and is a clean way to provide the necessary information. 

## Description

At this point in time, Q# supports two functors: `Adjoint` and `Controlled`. 
While in theory any transformation that supports either one of those two functors necessarily should support the other one, in practice it may be hard to determine an implementation for the transformation after functor application. 
This is the case e.g. for probabilistic implementations relying on repeat-until-success patterns. 
For that reason, Q# treats those two functors independently and allows programs to specify an operation that only supports one but not the other functor. 
If both functors are supported, then the properties of the two functors imply that the combination thereof has to be supported as well. 
Conversely, if the combination is specified, then each functor has to be supported on its own right.

### Current Status

Failing to explicitly declare the existence of a functor specialization that has to exist according to the above considerations currently 
results in a compiler warning and an attempted auto-generation for the missing specialization(s), which results in a compilation failure if the auto-generation fails. 
Such a generation is consistent with the use of the generation directive `auto`, that - like a user-defined implementation - is always valid but subject to certain limitations.

Each functor has its own set of supported generator directives that provide increased control over how the implementation is generated. 
In particular, these generation directives can be used to specify based on which specialization the implementation is to be generated. 
The directive `auto` indicates that a suitable generation directive should be determined by the compiler. 

For the vast majority of cases it is possible for the compiler to automatically determine a suitable directive. 
However, in some cases the compiler determined auto-generation may be too complex and fail, or the generated implementation may not be efficient enough. 
Auto-generation of an adjoint specialization for example currently fails for performance reasons if the operation uses mutability. 
In these cases it is hence necessary to either specify a custom implementation, or manually specify a suitable generation directive.  

#### Examples

Example 1:    
User-Defined Functor Specializations

```qsharp
operation Op () : Unit {                    // `Op` is of type (Unit => Unit)
                                            // and does not support any functor application
    body (...) {                            // default specialization
        Message ("invocation of 'Op'"); 
    }
}

operation Adjointable () : Unit {           // `Adjointable` is of type (Unit => Unit is Adj)
                                            // and supports application of the `Adjoint` functor
    body (...) {                            // default specialization
        Message ("invocation of 'Adjointable'"); 
    }

    adjoint (...) {                         // adjoint specialization
        Message ("invocation of 'Adjoint Adjointable'"); 
    }
}

operation Controllable () : Unit {          // `Controllable` is of type (Unit => Unit is Ctl)
                                            // and supports application of the `Controlled` functor
    body (...) {                            // default specialization
        Message ("invocation of 'Controllable'"); 
    }

    controlled (cs, ...) {                  // controlled specialization
        Message ("invocation of 'Controlled Controllable'"); 
    }
}

operation Unitary () : Unit {               // `Unitary` is of type (Unit => Unit is Ctl + Adj)
                                            // and supports both `Adjoint` and `Controlled`
    body (...) {                            // default specialization
        Message ("invocation of 'Unitary'"); 
    }

    adjoint (...) {                         // adjoint specialization
        Message ("invocation of 'Adjoint Unitary'"); 
    }

    controlled (cs, ...) {                  // controlled specialization
        Message ("invocation of 'Controlled Unitary'"); 
    }

    controlled adjoint (cs, ...) {          // controlled adjoint specialization
        Message ("invocation of 'Controlled Adjoint Unitary'"); 
    }
}
```

Example 2:    
Functor Specializations Defined via Generation Directives

```qsharp
operation SelfAdjOp () : Unit { 
    body (...) { }
    adjoint self;                           // indicates that `Adjoint SelfAdjOp` equals `SelfAdjOp`
}

operation Unitary1 () : Unit { 
    body (...) { }
    adjoint invert;
    controlled distribute;
    controlled adjoint invert;              // generation based on the controlled specialization
}

operation Unitary2 () : Unit { 
    body (...) { }
    adjoint invert;
    controlled distribute;
    controlled adjoint distribute;          // generation based on the adjoint specialization
}

operation Unitary3 () : Unit { 
    body (...) { }
    controlled distribute;
    adjoint self;                           // if an operation `Op` is self-adjoint then 
    controlled adjoint self;                // `Controlled Op` is necessarily self-adjoint, too
}  
```

Example 3:    
Specialization Generation Directive `auto`    
(currently supported directives are `auto`, `distribute`, `invert`, and `self`)

```qsharp
operation Unitary1 () : Unit { 
    body (...) { 
        // user-defined implementation
    }
    adjoint auto;                           // resolves to the generation directive `invert` 
    controlled auto;                        // resolves to the generation directive `distribute`
    controlled adjoint auto;                // resolves to the generation directive `distribute`
}

operation Unitary2 () : Unit { 
    body (...) { 
        // user-defined implementation
    }
    adjoint self;
    controlled auto;                        // resolves to the generation directive `distribute`
    controlled adjoint auto;                // resolves to the generation directive `self`
}

operation Unitary3 () : Unit { 
    body (...) { 
        // user-defined implementation
    }
    adjoint auto;                           // resolves to the generation directive `self`
    controlled auto;                        // resolves to the generation directive `distribute`
    controlled adjoint self;
}

operation Unitary4 () : Unit { 
    body (...) { 
        // user-defined implementation
    }
    controlled (cs, ...) {
        // user-defined implementation
    } 
    adjoint auto;                           // the resolution `invert` is used for both the adjoint
    controlled adjoint auto;                // and the corresponding controlled adjoint specialization
}

operation Unitary5 () : Unit { 
    body (...) { 
        // user-defined implementation
    }
    adjoint (...) {
        // user-defined implementation
    } 
    controlled auto;                        // the resolution `distribute` is used for the controlled
    controlled adjoint auto;                // and the corresponding controlled adjoint specialization
}

operation Unitary6 () : Unit { 
    body (...) { 
        // user-defined implementation
    }
    adjoint (...) {
        // user-defined implementation
    } 
    controlled (cs, ...) {
        // user-defined implementation
    } 
    controlled adjoint auto;                // resolves to the generation directive `distribute`
}

```

Example 4:    
Most Frequently Used Declarations

```qsharp
operation Op () : Unit {                    // direct implementation for the default specialization
    Message ("invocation of 'Op'");         // is allowed if no other specialization is declared
}

function Fct () : Unit {                    // the same holds for functions
    Message ("invocation of 'Fct'"); 
}

operation Unitary () : Unit { 
    body (...) { 
        // user-defined implementation
    }
    adjoint auto;                           // generation directive is determined by the compiler
    controlled auto;
    controlled adjoint auto; 
}
```

### Proposed Modification

To remove the need to explicitly specify a growing number of specializations that do not add any value to the code, 
the relevant functor support can be expressed as an annotation to the callable declaration that specifies (part of) the operation characteristics. 
Such an annotation as part of the operation declaration is optional and minimal in the sense that the operation is guaranteed to provide the support implied by the specified characteristics but might provide more. 
The correct characteristics of an operation are inferred, respectively completed, based on the explicitly defined specializations within the declaration. 

All existing specializations that are not explicitly defined will be generated by the compiler following the `auto` generation directive. 
If the auto-generation fails, the corresponding errors will be indicated within the relevant user-defined implementation based on which the implementation is generated. 
All diagnostics regarding missing specializations will be eliminated, with the exception of a remaining error given whenever the default body specialization is missing. 

Whether an operation is self-adjoint cannot readily and efficiently be detected by the compiler. 
Correspondingly, either an adjoint or a controlled adjoint specialization needs to be specified explicitly in order to indicate that an operation is self-adjoint.
The same holds for specializations where using the directive `auto` would not yield the desired results. 

#### Examples

<a id="example1"></a>Example 1:    
Unitary Operation with Implicitly Declared Functor Specializations

```qsharp
operation Unitary () : Unit                 // the adjoint, controlled, and controlled adjoint 
is Adj + Ctl {                              // specializations are automatically generated 

    // user-defined implementation          // implementation of the default body
}
```

Example 2:    
Unitary Operation with Explicitly Declared Functor Specializations    
(equivalent to [Example 1](#example1))

```qsharp
operation Unitary () : Unit {               // the characteristics are inferred to be Adj + Ctl
    body (...) {
        // user-defined implementation 
    }
    adjoint auto;                           // as with the current version of Q#, explicit
    controlled auto;                        // specializations can either be user-defined or
    controlled adjoint auto;                // generated according to the specified directive
}
```

Example 3:    
Equivalent Declarations of a Self-Adjoint Unitary Operation

```qsharp
operation SelfAdjointUnitary1 () : Unit 
is Adj + Ctl {
    body (...) { }                          // the controlled and controlled adjoint 
    adjoint self;                           // specializations are automatically generated
}

operation SelfAdjointUnitary2 () : Unit
is Ctl {                                    // the full characteristics are inferred to be Adj + Ctl
    body (...) { } 
    adjoint self;
}

operation SelfAdjointUnitary3 () : Unit 
is Adj + Ctl {                              // redundant and can thus be entirely omitted
    body (...) { } 
    controlled adjoint self;
}
```

## Implementation

Almost no additional infrastructure is needed. 
The new functionality only requires a minimal addition to the parsing as well as a minor adaption 
to ensure that implicitly defined specializations are correctly inserted and the operation characteristics are accurately resolved.

### Timeline

The change is proposed as part of the December 2018 review cycle, with an expected implementation for Summer 2019. 

## Further Considerations

Eliminating the need to explicitly specify specializations unless their implementation is either user-defined or following a non-standard generation directive greatly reduces the verbosity of operation declarations. 
For most operations only a default body specialization will need to be declared explicitly, which can then be expressed as part of the declaration itself rather than within a specialization declaration as it is usually done for functions. This changes the overall appearance of Q# code to be more aligned with other programming languages. 

### Related Mechanisms

Purely in terms of syntax, the annotations on operation declarations that indicate (part of) the properties should follow the same pattern as the corresponding annotation on operation types. 
It is worth mentioning that adhering to the exact same syntax implies that the compulsory parenthesis around operation types cannot be made optional 
due to the ambiguity between an operation type annotation of the return type <nobr>(`operation Foo () : (Unit => Unit is Adj) { ... }`)</nobr> 
and an annotation to the operation itself <nobr>(`operation Foo () : (Unit => Unit) is Adj { ... }`)</nobr>. 
The two cases cannot be disambiguated without compulsory parentheses around operation types 
since optional inner parenthesis of the form <nobr>`((Unit => Unit) is Adj)`</nobr> around operation types have been supported since Q# version 0.3. 

### Impact on Existing Mechanisms

The proposed additional functionality is purely for user convenience, and does not impact any existing mechanisms. 

### Anticipated Interactions with Future Modifications

One possible future evolution is the introduction of type specializations for type parametrized operations and functions. 
It is thus important to consider whether and how the proposed partial inference of existing specializations and the operation characteristics is possible in this case. 
Discussing all considerations and requirements pertinent to introducing type specializations is out of scope for this proposal, 
but it seems reasonable to follow the path that such callables should behave as if each set of type arguments were to define their very own distinct callable. 
In that case, the proposed partial inference is applicable as suggested for each callable and set of type arguments for which the callable has been specialized. 

Building on such a path, it is also conceivable that if type specializations are supported, 
it might be nice to allow to declare specializations on a global scope outside the original callable declaration. Such a potential feature should not interfere with the features in this proposal. 

### Alternatives

1. By allowing to annotate a callable declaration with complete or partial characteristics, 
which specializations should exist can easily be determined without the need to do operation type inference across declaration boundaries. 
One might wonder, however, whether it would be possible to do more than that and implement a full inference algorithm that analyzes all operation declarations and determines which functor specializations should exist without requiring explicit annotations.  

2. Conversely, one could wonder whether allowing to specify only part of the operation characteristics as an annotation might cause confusion. 
One might want to make a characteristic annotation mandatory, or at least require that the annotation is either complete or absent. 

3. Arguably there should be a way to more clearly distinguish the characteristics annotations within a callable declaration from annotations that are part of operation return types. 
There might be a cleaner way to separate the operation characteristics from the rest of the signature, though a better syntax is not obvious.

### Comparison to Alternatives

1. While a complete inference of operation characteristics might be desirable, it would involve a significant amount of non-trivial work. 
For now and in the near future, it makes sent to prioritize other improvements to the language. 
If Q# at some point supports full inference in that regard, it would still be desirable to allow explicit annotations on operation declarations for the sake of clarity and code safety. 
Introducing partial inference as proposed here therefore seems like a reasonable step independent of future developments. 

2. Making the characteristics annotation optional seems reasonable in order to avoid an unnecessary breaking change relative to what is supported today. 
One would have to introduce a way to disambiguate the absence of an annotation and an operation simply not having any of the tracked and labeled properties like e.g. the support of certain functors. 
Alternatively, one has to concede that any annotation - or lack thereof - on the operation declaration is always minimal in the sense that the operation is guaranteed to have the declared properties but might have more. 
<br><br>
The question of whether or not it should be possible to declare only part of the operation characteristics or not is a different question, and the concern that an incomplete annotation might be confusing to the reader is justified. 
When considering whether it is possible to require that the annotation on an operation declaration needs to be complete or omitted entirely, 
it is important to take the possibility of potentially supporting type specializations into account. 
If such a support is added to Q#, then each set of functor specializations for a certain set of type arguments may have its own distinct characteristics. 
In that case, the options are to either have the means to somehow specify the characteristics along with the type parameters for which to specialize, force the user to explicitly declare all specializations in this case, or drop the completeness requirement for the characteristics annotation on declaration. 
The first option would certainly be possible and in a sense not much different than being able to define the type arguments for which to specialize in the first place. 
The second option would partially defeat the purpose of this proposal specifically in some cases where it could be very beneficial in reducing the burden on the developer. 
All in all, it seems that accepting that the characteristics specified as part the callable declaration are a minimal guarantee regarding which properties and support the operation has to provide independent on what it is specialized for seems the most flexible, consistent, and convenient approach - but that is certainly debatable. 

3. Overall I hope it is more clarifying rather than confusing to use the same syntax for annotating the operation characteristics on declarations as on operation types. 

## Raised Concerns

Any concerns about the proposed modification will be listed here and are addressed in the [Response](#response) section below. 

### Response 
