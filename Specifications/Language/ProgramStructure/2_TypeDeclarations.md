# Type Declarations

Q# has minimal support for custom types. Custom types are similar to record types in F#; they are immutable but support a [copy-and-update](https://github.com/microsoft/qsharp-language/tree/beheim/specs/Specifications/Language) construct. 
Such custom types may contain both named and anonymous items. 
The contained items can be accessed via the [item access](https://github.com/microsoft/qsharp-language/tree/beheim/specs/Specifications/Language) operator.

The following declaration within a namespace for instance defines a type `Complex` which has two named items `Real` and `Imaginary`, both of type `Double`:
```qsharp
    newtype Complex = (Real: Double, Imaginary : Double);
```

User defined types are particularly useful for two reasons. For one, 
as long as the libraries and programs that use the defined types access items via their name rather than by deconstruction, the type can be extended to contain additional items later on without breaking any of the library code. Accessing items via deconstruction is hence generally discouraged.

Furthermore, they allow to clearly convey the intent and expectations for a certain data type. For instance, the arithmetic library includes quantum arithmetic operations for both big-endian and little-endian quantum integers.
It hence defines two types, `BigEndian` and `LittleEndian`, both of which contain a single anonymous item of type `Qubit[]`:
```qsharp
    newtype BigEndian = Qubit[];
    newtype LittleEndian = Qubit[];
```
This allows operations to specify whether they are written for big-endian or little-endian representations, and leverages the type system to ensure at compile-time that mismatched operands aren't allowed.

Types may not have circular dependencies in Q#; defining something like a directly or indirectly recursive type is not possible, i.e. the following construct will give a compilation error: 
```qsharp
    newtype Foo = (Foo, Int); // gives an error
    newtype Bar = Baz;        // gives an error
    newtype Baz = Bar;        // gives an error
```

Udt constructors are automatically generated by the compiler. Currently, it is not yet possible to define a custom constructor, though this would certainly be a desireable addition to the language in the future. 
