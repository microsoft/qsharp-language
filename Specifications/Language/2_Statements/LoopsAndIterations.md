# Loops and Iterations

In terms of execution, loops that break based on a condition can be a huge challenge to process on quantum hardware if the condition depends on measurement outcomes; this poses an extra challenge since the length of the instruction sequence to execute is not known ahead of time. Despite that, Q# supports such constructs. The repeat-until-success pattern is a vital ingredient to a lot of quantum algorithms. Q# hence has its own dedicated statement for these: the `repeat`-statement. The statement consists of a first block to execute, after which a condition is evaluated. If the condition evaluates to true, the loop exists. If the condition evaluates to false, an addition block of statements defined as part of an optional `fixup`-block is executed prior to entering the next loop iteration. 

Despite their common presence in particular classes of quantum algorithms, current hardware does not yet provide native support for these kind of control flow constructs. Execution on a quantum processor hence currently requires to impose a maximum recursion depth, and comes at a heavy cost to the size of compiled binaries; the loop in a sense is unrolled. It is translated and handled in much the same way as a recursion containing branchings based on measurement results would be. This means that the instructions for every possible execution path need to be explicitly represented in the compilation, hence the exponential increase in size of the binary. 

In an effort to provide a more familiar looking statement for classical computations, a traditional `while`-loop is also supported, albeit only within functions to discourage the use of loops that break based on a condition when dealing with quantum computation, unless they are needed. With more sophisticated tracking regarding when a value depends on the quantum parts of a computation, it will be possible to allow the use of `while`-loops within operations as well, as long as the condition does not depend on quantum instructions within the body of the loop. 
There is also no reason not to support other kinds of commonly available loop constructs within functions in the future. 

Much more benign on the other hand are loops that merely iterate over a sequence of values. Q# hence carefully distinguishes between `repeat`-statements and `for`-loops. A `for`-loop in Q# does not break based on a condition, but instead corresponds to what is often expressed as `foreach` or `iter` in other languages. There are furthermore no `break`- or `continue`-primitives in Q#, such that the length of the loop is perfectly predictable as soon as the value to iterate over is known. Of course, the length of the iteration may still depend on runtime information. However, at least in principle it is possible to make estimates regarding that length, facilitated by the fact that there is no concept of standard input during quantum execution, and programs are compiled for a given set of inputs. 

There are currently two date types in Q# that support iteration: arrays and ranges. 
The same deconstruction rules apply to the defined loop variable(s) as to any other variable assignment, such as bindings in `let`-, `mutable`-, `set`-, `using`- and `borrowing`-statements. The loop variables themselves are immutably bound, cannot be reassigned within the body of the loop, and go out of scope when the loop terminates. 
